{"version":3,"sources":["webpack:///./node_modules/maptalks.markercluster/dist/maptalks.markercluster.es.js","webpack:///./node_modules/maptalks.heatmap/dist/maptalks.heatmap.es.js","webpack:///src/views/map/maptalks/map.vue","webpack:///./src/views/map/maptalks/map.vue?bd11","webpack:///./src/views/map/maptalks/map.vue"],"names":["_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","obj","defaults","keys","getOwnPropertyNames","i","length","key","getOwnPropertyDescriptor","undefined","defineProperty","_defaults","maptalks_markercluster_es_ClusterLayer","_maptalks$VectorLayer","ClusterLayer","this","apply","arguments","fromJSON","json","layer","geoJSONs","geometries","geo","maptalks_es","push","addGeometry","addMarker","markers","len","Error","onConfig","conf","renderer$$1","_getRenderer","render","identify","coordinate","options","map","getMap","maxZoom","getZoom","toJSON","getClusters","_currentClusters","mergeOptions","maxClusterRadius","textSumProperty","symbol","drawClusterText","textSymbol","animation","animationDuration","maxClusterZoom","noClusterWithOneMarker","forceRenderOnZooming","registerJSONType","defaultTextSymbol","textFaceName","textSize","textDx","textDy","defaultSymbol","markerType","markerFill","property","type","stops","markerFillOpacity","markerLineOpacity","markerLineWidth","markerLineColor","markerWidth","markerHeight","registerRenderer","_maptalks$renderer$Ve","_class","_this2","_animated","_refreshStyle","_clusterNeedRedraw","checkResources","resources","_symbolResourceChecked","res","getExternalResources","draw","canvas","prepareCanvas","zoom","_markersToDraw","_geoList","_clearDataCache","_computeGrid","zoomClusters","_clusterCache","clusters","_getClustersToDraw","_drawLayer","font","getFont","_textSymbol","digitLen","stringLength","toPoint","extent","getContainerExtent","pt","pExt","sprite","width","height","p","_currentGrid","marker","_cluster","_getSprite","_prjToContainerPoint","sub","add","intersects","text","_getClusterText","x","y","_multi","drawOnInteracting","_drawClusters","forEachGeo","fn","context","forEach","g","onGeometryAdd","onGeometryRemove","onGeometryPositionChange","onRemove","point","coordinateToContainerPoint","old","c","distanceTo","center","getProjection","unproject","copy","children","slice","_hitGeos","onSymbolChanged","_stopAnim","setToRedraw","_this3","argFn","_symbol","loadFunctionTypes","_this4","parentClusters","_clusterMaskExtent","_inout","dr","_player","Animation","animate","d","speed","easing","frame","state","playState","_drawMarkers","completeRender","_drawClustersFrame","styles","setCanvasUpdated","play","drawGeos","toClusters","ratio","_this5","drawn","_drawCluster","z","r","_getResolution","min","_markerExtent","getMin","pkey","Math","floor","parent","pp","_this6","cluster","op","ctx","opacity","globalAlpha","pos","offset","_sub","drawImage","prepareCanvasFont","dx","dy","fillText","_spriteCache","getSymbolStamp","CanvasClass","_initGridSystem","points","_getPrjCoordinates","_combine","_getPrjExtent","id","_getInternalId","geometry","_markerPoints","pre","getMinZoom","getMaxZoom","getCount","_computeZoomGrid","preT","preCache","sumProperty","grids","sumProp","getProperties","_add","multi","sum","count","_mergeClusters","clusterMap","merging","visited","c1","c2","_p","gxgy","split","gx","gy","ii","iii","_distanceTo","m","grid","toMerge","concat","sqrt","finish","onZoomStart","param","onZoomEnd","isEmpty","isVisible","_zoomInClusters","VectorLayerCanvasRenderer","console","log","simpleheat_1","module","exports","createCommonjsModule","simpleheat","_canvas","document","getElementById","_ctx","getContext","_width","_height","_max","_data","defaultRadius","defaultGradient","0.4","0.6","0.7","0.8","1","data","max","clear","radius","blur","circle","_circle","_createCanvas","r2","_r","shadowOffsetX","shadowOffsetY","shadowBlur","shadowColor","beginPath","arc","PI","closePath","fill","resize","gradient","grad","createLinearGradient","addColorStop","fillStyle","fillRect","_grad","getImageData","minOpacity","clearRect","colored","_colorize","putImageData","pixels","j","createElement","maptalks_heatmap_es__classCallCheck","maptalks_heatmap_es__possibleConstructorReturn","maptalks_heatmap_es__inherits","maptalks_heatmap_es__defaults","maptalks_heatmap_es_options","maptalks_heatmap_es_HeatLayer","_maptalks$Layer","HeatLayer","heats","Array","isArray","_this","_heats","getData","setData","redraw","addPoint","heat","pushIn","clearHeatCache","fire","getJSONType","getId","config","clipExtent","_getHeatRadius","_expand","clipped","contains","_heatRadius","_maptalks$renderer$Ca","maskExtent","displayExtent","convertTo","_pointToContainerPoint","intersection","_heater","_heatViews","_heatData","projection","isNil","v","pow","cellSize","panePos","offsetPlatform","offsetX","offsetY","cell","k","expand","_containerPointToPrj","l","project","alt","_i","_l","ll","round","onResize","CanvasRenderer","maptalks_map","attribution","removeAllLayer","addclusterLayer","addHeatLayer","clusterLayer","markerVectorLayer","heatLayer","_marker","getCoordinates","features","hull","addTo","clustervectorLayer","initMap","map_maptalks_map","_vm","_h","$createElement","_c","_self","staticClass","attrs","_v","on","click","$event","updateLayer","clearlayer","distance","area","staticRenderFns","Component","__webpack_require__","normalizeComponent","ssrContext","__webpack_exports__"],"mappings":"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","file":"static/js/17.ac32458b976632300ef5.js","sourcesContent":["/*!\n * maptalks.markercluster v0.8.2\n * LICENSE : MIT\n * (c) 2016-2018 maptalks.org\n */\n/*!\n * requires maptalks@>=0.26.3 \n */\nimport { Canvas, Coordinate, Geometry, MapboxUtil, Marker, Point, PointExtent, StringUtil, Util, VectorLayer, animation, renderer } from 'maptalks';\n\nfunction _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }\n\nvar options = {\n    'maxClusterRadius': 160,\n    'textSumProperty': null,\n    'symbol': null,\n    'drawClusterText': true,\n    'textSymbol': null,\n    'animation': true,\n    'animationDuration': 450,\n    'maxClusterZoom': null,\n    'noClusterWithOneMarker': true,\n    'forceRenderOnZooming': true\n};\n\nvar ClusterLayer = function (_maptalks$VectorLayer) {\n    _inherits(ClusterLayer, _maptalks$VectorLayer);\n\n    function ClusterLayer() {\n        _classCallCheck(this, ClusterLayer);\n\n        return _possibleConstructorReturn(this, _maptalks$VectorLayer.apply(this, arguments));\n    }\n\n    /**\r\n     * Reproduce a ClusterLayer from layer's profile JSON.\r\n     * @param  {Object} json - layer's profile JSON\r\n     * @return {maptalks.ClusterLayer}\r\n     * @static\r\n     * @private\r\n     * @function\r\n     */\n    ClusterLayer.fromJSON = function fromJSON(json) {\n        if (!json || json['type'] !== 'ClusterLayer') {\n            return null;\n        }\n        var layer = new ClusterLayer(json['id'], json['options']);\n        var geoJSONs = json['geometries'];\n        var geometries = [];\n        for (var i = 0; i < geoJSONs.length; i++) {\n            var geo = Geometry.fromJSON(geoJSONs[i]);\n            if (geo) {\n                geometries.push(geo);\n            }\n        }\n        layer.addGeometry(geometries);\n        return layer;\n    };\n\n    ClusterLayer.prototype.addMarker = function addMarker(markers) {\n        return this.addGeometry(markers);\n    };\n\n    ClusterLayer.prototype.addGeometry = function addGeometry(markers) {\n        for (var i = 0, len = markers.length; i <= len; i++) {\n            if (!markers[i] instanceof Marker) {\n                throw new Error('Only a point(Marker) can be added into a ClusterLayer');\n            }\n        }\n        return _maptalks$VectorLayer.prototype.addGeometry.apply(this, arguments);\n    };\n\n    ClusterLayer.prototype.onConfig = function onConfig(conf) {\n        _maptalks$VectorLayer.prototype.onConfig.call(this, conf);\n        if (conf['maxClusterRadius'] || conf['symbol'] || conf['drawClusterText'] || conf['textSymbol'] || conf['maxClusterZoom']) {\n            var renderer$$1 = this._getRenderer();\n            if (renderer$$1) {\n                renderer$$1.render();\n            }\n        }\n        return this;\n    };\n\n    /**\r\n     * Identify the clusters on the given coordinate\r\n     * @param  {maptalks.Coordinate} coordinate   - coordinate to identify\r\n     * @return {Object|Geometry[]}  result: cluster { center : [cluster's center], children : [geometries in the cluster] } or markers\r\n     */\n\n\n    ClusterLayer.prototype.identify = function identify(coordinate, options) {\n        var map = this.getMap(),\n            maxZoom = this.options['maxClusterZoom'];\n        if (maxZoom && map && map.getZoom() > maxZoom) {\n            return _maptalks$VectorLayer.prototype.identify.call(this, coordinate, options);\n        }\n        if (this._getRenderer()) {\n            return this._getRenderer().identify(coordinate, options);\n        }\n        return null;\n    };\n\n    /**\r\n     * Export the ClusterLayer's JSON.\r\n     * @return {Object} layer's JSON\r\n     */\n\n\n    ClusterLayer.prototype.toJSON = function toJSON() {\n        var json = _maptalks$VectorLayer.prototype.toJSON.call(this);\n        json['type'] = 'ClusterLayer';\n        return json;\n    };\n    /**\r\n     * Get the ClusterLayer's current clusters\r\n     * @return {Object} layer's clusters\r\n     **/\n\n\n    ClusterLayer.prototype.getClusters = function getClusters() {\n        var renderer$$1 = this._getRenderer();\n        if (renderer$$1) {\n            return renderer$$1._currentClusters || [];\n        }\n        return [];\n    };\n\n    return ClusterLayer;\n}(VectorLayer);\n\n// merge to define ClusterLayer's default options.\nClusterLayer.mergeOptions(options);\n\n// register ClusterLayer's JSON type for JSON deserialization.\nClusterLayer.registerJSONType('ClusterLayer');\n\nvar defaultTextSymbol = {\n    'textFaceName': '\"microsoft yahei\"',\n    'textSize': 16,\n    'textDx': 0,\n    'textDy': 0\n};\n\nvar defaultSymbol = {\n    'markerType': 'ellipse',\n    'markerFill': { property: 'count', type: 'interval', stops: [[0, 'rgb(135, 196, 240)'], [9, '#1bbc9b'], [99, 'rgb(216, 115, 149)']] },\n    'markerFillOpacity': 0.7,\n    'markerLineOpacity': 1,\n    'markerLineWidth': 3,\n    'markerLineColor': '#fff',\n    'markerWidth': { property: 'count', type: 'interval', stops: [[0, 40], [9, 60], [99, 80]] },\n    'markerHeight': { property: 'count', type: 'interval', stops: [[0, 40], [9, 60], [99, 80]] }\n};\n\nClusterLayer.registerRenderer('canvas', function (_maptalks$renderer$Ve) {\n    _inherits(_class, _maptalks$renderer$Ve);\n\n    function _class(layer) {\n        _classCallCheck(this, _class);\n\n        var _this2 = _possibleConstructorReturn(this, _maptalks$renderer$Ve.call(this, layer));\n\n        _this2._animated = true;\n        _this2._refreshStyle();\n        _this2._clusterNeedRedraw = true;\n        return _this2;\n    }\n\n    _class.prototype.checkResources = function checkResources() {\n        var symbol = this.layer.options['symbol'] || defaultSymbol;\n        var resources = _maptalks$renderer$Ve.prototype.checkResources.apply(this, arguments);\n        if (symbol !== this._symbolResourceChecked) {\n            var res = Util.getExternalResources(symbol, true);\n            if (res) {\n                resources.push.apply(resources, res);\n            }\n            this._symbolResourceChecked = symbol;\n        }\n        return resources;\n    };\n\n    _class.prototype.draw = function draw() {\n        if (!this.canvas) {\n            this.prepareCanvas();\n        }\n        var map = this.getMap();\n        var zoom = map.getZoom();\n        var maxClusterZoom = this.layer.options['maxClusterZoom'];\n        if (maxClusterZoom && zoom > maxClusterZoom) {\n            delete this._currentClusters;\n            this._markersToDraw = this.layer._geoList;\n            _maptalks$renderer$Ve.prototype.draw.apply(this, arguments);\n            return;\n        }\n        if (this._clusterNeedRedraw) {\n            this._clearDataCache();\n            this._computeGrid();\n            this._clusterNeedRedraw = false;\n        }\n        var zoomClusters = this._clusterCache[zoom] ? this._clusterCache[zoom]['clusters'] : null;\n\n        var clusters = this._getClustersToDraw(zoomClusters);\n        clusters.zoom = zoom;\n        this._drawLayer(clusters);\n    };\n\n    _class.prototype._getClustersToDraw = function _getClustersToDraw(zoomClusters) {\n        this._markersToDraw = [];\n        var map = this.getMap();\n        var font = StringUtil.getFont(this._textSymbol),\n            digitLen = StringUtil.stringLength('9', font).toPoint();\n        var extent = map.getContainerExtent(),\n            clusters = [];\n        var pt = void 0,\n            pExt = void 0,\n            sprite = void 0,\n            width = void 0,\n            height = void 0;\n        for (var p in zoomClusters) {\n            this._currentGrid = zoomClusters[p];\n            if (zoomClusters[p]['count'] === 1 && this.layer.options['noClusterWithOneMarker']) {\n                var marker = zoomClusters[p]['children'][0];\n                marker._cluster = zoomClusters[p];\n                this._markersToDraw.push(marker);\n                continue;\n            }\n            sprite = this._getSprite();\n            width = sprite.canvas.width;\n            height = sprite.canvas.height;\n            pt = map._prjToContainerPoint(zoomClusters[p]['center']);\n            pExt = new PointExtent(pt.sub(width, height), pt.add(width, height));\n            if (!extent.intersects(pExt)) {\n                continue;\n            }\n\n            if (!zoomClusters[p]['textSize']) {\n                var text = this._getClusterText(zoomClusters[p]);\n                zoomClusters[p]['textSize'] = new Point(digitLen.x * text.length, digitLen.y)._multi(1 / 2);\n            }\n            clusters.push(zoomClusters[p]);\n        }\n        return clusters;\n    };\n\n    _class.prototype.drawOnInteracting = function drawOnInteracting() {\n        if (this._currentClusters) {\n            this._drawClusters(this._currentClusters, 1);\n        }\n        _maptalks$renderer$Ve.prototype.drawOnInteracting.apply(this, arguments);\n    };\n\n    _class.prototype.forEachGeo = function forEachGeo(fn, context) {\n        if (this._markersToDraw) {\n            this._markersToDraw.forEach(function (g) {\n                if (context) {\n                    fn.call(context, g);\n                } else {\n                    fn(g);\n                }\n            });\n        }\n    };\n\n    _class.prototype.onGeometryAdd = function onGeometryAdd() {\n        this._clusterNeedRedraw = true;\n        _maptalks$renderer$Ve.prototype.onGeometryAdd.apply(this, arguments);\n    };\n\n    _class.prototype.onGeometryRemove = function onGeometryRemove() {\n        this._clusterNeedRedraw = true;\n        _maptalks$renderer$Ve.prototype.onGeometryRemove.apply(this, arguments);\n    };\n\n    _class.prototype.onGeometryPositionChange = function onGeometryPositionChange() {\n        this._clusterNeedRedraw = true;\n        _maptalks$renderer$Ve.prototype.onGeometryPositionChange.apply(this, arguments);\n    };\n\n    _class.prototype.onRemove = function onRemove() {\n        this._clearDataCache();\n    };\n\n    _class.prototype.identify = function identify(coordinate, options) {\n        var map = this.getMap(),\n            maxZoom = this.layer.options['maxClusterZoom'];\n        if (maxZoom && map.getZoom() > maxZoom) {\n            return _maptalks$renderer$Ve.prototype.identify.call(this, coordinate, options);\n        }\n        if (this._currentClusters) {\n            var point = map.coordinateToContainerPoint(coordinate);\n            var old = this._currentGrid;\n            for (var i = 0; i < this._currentClusters.length; i++) {\n                var c = this._currentClusters[i];\n                var pt = map._prjToContainerPoint(c['center']);\n                this._currentGrid = c;\n                var markerWidth = this._getSprite().canvas.width;\n\n                if (point.distanceTo(pt) <= markerWidth) {\n                    return {\n                        'center': map.getProjection().unproject(c.center.copy()),\n                        'children': c.children.slice(0)\n                    };\n                }\n            }\n            this._currentGrid = old;\n        }\n\n        // if no clusters is hit, identify markers\n        if (this._markersToDraw) {\n            return this.layer._hitGeos(this._markersToDraw, coordinate, options);\n        }\n        return null;\n    };\n\n    _class.prototype.onSymbolChanged = function onSymbolChanged() {\n        this._refreshStyle();\n        this._computeGrid();\n        this._stopAnim();\n        this.setToRedraw();\n    };\n\n    _class.prototype._refreshStyle = function _refreshStyle() {\n        var _this3 = this;\n\n        var symbol = this.layer.options['symbol'] || defaultSymbol;\n        var textSymbol = this.layer.options['textSymbol'] || defaultTextSymbol;\n        var argFn = function argFn() {\n            return [_this3.getMap().getZoom(), _this3._currentGrid];\n        };\n        this._symbol = MapboxUtil.loadFunctionTypes(symbol, argFn);\n        this._textSymbol = MapboxUtil.loadFunctionTypes(textSymbol, argFn);\n    };\n\n    _class.prototype._drawLayer = function _drawLayer(clusters) {\n        var _this4 = this;\n\n        var parentClusters = this._currentClusters || clusters;\n        this._currentClusters = clusters;\n        delete this._clusterMaskExtent;\n        var layer = this.layer;\n        //if (layer.options['animation'] && this._animated && this._inout === 'out') {\n        if (layer.options['animation'] && this._animated && this._inout) {\n            var dr = [0, 1];\n            if (this._inout === 'in') {\n                dr = [1, 0];\n            }\n            this._player = animation.Animation.animate({ 'd': dr }, { 'speed': layer.options['animationDuration'], 'easing': 'inAndOut' }, function (frame) {\n                if (frame.state.playState === 'finished') {\n                    _this4._animated = false;\n                    _this4._drawClusters(clusters, 1);\n                    _this4._drawMarkers();\n                    _this4.completeRender();\n                } else {\n                    if (_this4._inout === 'in') {\n                        _this4._drawClustersFrame(clusters, parentClusters, frame.styles.d);\n                    } else {\n                        _this4._drawClustersFrame(parentClusters, clusters, frame.styles.d);\n                    }\n                    _this4.setCanvasUpdated();\n                }\n            }).play();\n        } else {\n            this._animated = false;\n            this._drawClusters(clusters, 1);\n            this._drawMarkers();\n            this.completeRender();\n        }\n    };\n\n    _class.prototype._drawMarkers = function _drawMarkers() {\n        _maptalks$renderer$Ve.prototype.drawGeos.call(this, this._clusterMaskExtent);\n    };\n\n    _class.prototype._drawClustersFrame = function _drawClustersFrame(parentClusters, toClusters, ratio) {\n        var _this5 = this;\n\n        this._clusterMaskExtent = this.prepareCanvas();\n        var map = this.getMap(),\n            drawn = {};\n        if (parentClusters) {\n            parentClusters.forEach(function (c) {\n                var p = map._prjToContainerPoint(c['center']);\n                if (!drawn[c.key]) {\n                    drawn[c.key] = 1;\n                    _this5._drawCluster(p, c, 1 - ratio);\n                }\n            });\n        }\n        if (ratio === 0 || !toClusters) {\n            return;\n        }\n        var z = parentClusters.zoom,\n            r = map._getResolution(z) * this.layer.options['maxClusterRadius'],\n            min = this._markerExtent.getMin();\n        toClusters.forEach(function (c) {\n            var pt = map._prjToContainerPoint(c['center']);\n            var center = c.center;\n            var pgx = Math.floor((center.x - min.x) / r),\n                pgy = Math.floor((center.y - min.y) / r);\n            var pkey = pgx + '_' + pgy;\n            var parent = _this5._clusterCache[z]['clusterMap'][pkey];\n            if (parent) {\n                var pp = map._prjToContainerPoint(parent['center']);\n                pt = pp.add(pt.sub(pp)._multi(ratio));\n            }\n            _this5._drawCluster(pt, c, ratio > 0.5 ? 1 : ratio);\n        });\n    };\n\n    _class.prototype._drawClusters = function _drawClusters(clusters, ratio) {\n        var _this6 = this;\n\n        if (!clusters) {\n            return;\n        }\n        this._clusterMaskExtent = this.prepareCanvas();\n        var map = this.getMap();\n        clusters.forEach(function (c) {\n            var pt = map._prjToContainerPoint(c['center']);\n            _this6._drawCluster(pt, c, ratio > 0.5 ? 1 : ratio);\n        });\n    };\n\n    _class.prototype._drawCluster = function _drawCluster(pt, cluster, op) {\n        this._currentGrid = cluster;\n        var ctx = this.context;\n        var sprite = this._getSprite();\n        var opacity = ctx.globalAlpha;\n        if (opacity * op === 0) {\n            return;\n        }\n        ctx.globalAlpha = opacity * op;\n        if (sprite) {\n            var pos = pt.add(sprite.offset)._sub(sprite.canvas.width / 2, sprite.canvas.height / 2);\n            ctx.drawImage(sprite.canvas, pos.x, pos.y);\n        }\n\n        if (this.layer.options['drawClusterText'] && cluster['textSize']) {\n            Canvas.prepareCanvasFont(ctx, this._textSymbol);\n            var dx = this._textSymbol['textDx'] || 0;\n            var dy = this._textSymbol['textDy'] || 0;\n            var text = this._getClusterText(cluster);\n            Canvas.fillText(ctx, text, pt.sub(cluster['textSize']).add(dx, dy));\n        }\n        ctx.globalAlpha = opacity;\n    };\n\n    _class.prototype._getClusterText = function _getClusterText(cluster) {\n        var text = this.layer.options['textSumProperty'] ? cluster['textSumProperty'] : cluster['count'];\n        return text + '';\n    };\n\n    _class.prototype._getSprite = function _getSprite() {\n        if (!this._spriteCache) {\n            this._spriteCache = {};\n        }\n        var key = Util.getSymbolStamp(this._symbol);\n        if (!this._spriteCache[key]) {\n            this._spriteCache[key] = new Marker([0, 0], { 'symbol': this._symbol })._getSprite(this.resources, this.getMap().CanvasClass);\n        }\n        return this._spriteCache[key];\n    };\n\n    _class.prototype._initGridSystem = function _initGridSystem() {\n        var points = [];\n        var extent = void 0,\n            c = void 0;\n        this.layer.forEach(function (g) {\n            c = g._getPrjCoordinates();\n            if (!extent) {\n                extent = g._getPrjExtent();\n            } else {\n                extent = extent._combine(g._getPrjExtent());\n            }\n            points.push({\n                x: c.x,\n                y: c.y,\n                id: g._getInternalId(),\n                geometry: g\n            });\n        });\n        this._markerExtent = extent;\n        this._markerPoints = points;\n    };\n\n    _class.prototype._computeGrid = function _computeGrid() {\n        var map = this.getMap(),\n            zoom = map.getZoom();\n        if (!this._markerExtent) {\n            this._initGridSystem();\n        }\n        if (!this._clusterCache) {\n            this._clusterCache = {};\n        }\n        var pre = map._getResolution(map.getMinZoom()) > map._getResolution(map.getMaxZoom()) ? zoom - 1 : zoom + 1;\n        if (this._clusterCache[pre] && this._clusterCache[pre].length === this.layer.getCount()) {\n            this._clusterCache[zoom] = this._clusterCache[pre];\n        }\n        if (!this._clusterCache[zoom]) {\n            this._clusterCache[zoom] = this._computeZoomGrid(zoom);\n        }\n    };\n\n    _class.prototype._computeZoomGrid = function _computeZoomGrid(zoom) {\n        if (!this._markerExtent) {\n            return null;\n        }\n        var map = this.getMap(),\n            r = map._getResolution(zoom) * this.layer.options['maxClusterRadius'],\n            preT = map._getResolution(zoom - 1) ? map._getResolution(zoom - 1) * this.layer.options['maxClusterRadius'] : null;\n        var preCache = this._clusterCache[zoom - 1];\n        if (!preCache && zoom - 1 >= map.getMinZoom()) {\n            this._clusterCache[zoom - 1] = preCache = this._computeZoomGrid(zoom - 1);\n        }\n        // 1. format extent of markers to grids with raidus of r\n        // 2. find point's grid in the grids\n        // 3. sum up the point into the grid's collection\n        var points = this._markerPoints;\n        var sumProperty = this.layer.options['textSumProperty'];\n        var grids = {},\n            min = this._markerExtent.getMin();\n        var gx = void 0,\n            gy = void 0,\n            key = void 0,\n            pgx = void 0,\n            pgy = void 0,\n            pkey = void 0;\n        for (var i = 0, len = points.length; i < len; i++) {\n            var geo = points[i].geometry;\n            var sumProp = 0;\n\n            if (sumProperty && geo.getProperties() && geo.getProperties()[sumProperty]) {\n                sumProp = geo.getProperties()[sumProperty];\n            }\n\n            gx = Math.floor((points[i].x - min.x) / r);\n            gy = Math.floor((points[i].y - min.y) / r);\n            key = gx + '_' + gy;\n            if (!grids[key]) {\n                grids[key] = {\n                    'sum': new Coordinate(points[i].x, points[i].y),\n                    'center': new Coordinate(points[i].x, points[i].y),\n                    'count': 1,\n                    'textSumProperty': sumProp,\n                    'children': [geo],\n                    'key': key + ''\n                };\n                if (preT && preCache) {\n                    pgx = Math.floor((points[i].x - min.x) / preT);\n                    pgy = Math.floor((points[i].y - min.y) / preT);\n                    pkey = pgx + '_' + pgy;\n                    grids[key]['parent'] = preCache['clusterMap'][pkey];\n                }\n            } else {\n\n                grids[key]['sum']._add(new Coordinate(points[i].x, points[i].y));\n                grids[key]['count']++;\n                grids[key]['center'] = grids[key]['sum'].multi(1 / grids[key]['count']);\n                grids[key]['children'].push(geo);\n                grids[key]['textSumProperty'] += sumProp;\n            }\n        }\n        return this._mergeClusters(grids, r / 2);\n    };\n\n    _class.prototype._mergeClusters = function _mergeClusters(grids, r) {\n        var clusterMap = {};\n        for (var p in grids) {\n            clusterMap[p] = grids[p];\n        }\n\n        // merge adjacent clusters\n        var merging = {};\n\n        var visited = {};\n        // find clusters need to merge\n        var c1 = void 0,\n            c2 = void 0;\n        for (var _p in grids) {\n            c1 = grids[_p];\n            if (visited[c1.key]) {\n                continue;\n            }\n            var gxgy = c1.key.split('_');\n            var gx = +gxgy[0],\n                gy = +gxgy[1];\n            //traverse adjacent grids\n            for (var ii = -1; ii <= 1; ii++) {\n                for (var iii = -1; iii <= 1; iii++) {\n                    if (ii === 0 && iii === 0) {\n                        continue;\n                    }\n                    var key2 = gx + ii + '_' + (gy + iii);\n                    c2 = grids[key2];\n                    if (c2 && this._distanceTo(c1['center'], c2['center']) <= r) {\n                        if (!merging[c1.key]) {\n                            merging[c1.key] = [];\n                        }\n                        merging[c1.key].push(c2);\n                        visited[c2.key] = 1;\n                    }\n                }\n            }\n        }\n\n        //merge clusters\n        for (var m in merging) {\n            var grid = grids[m];\n            if (!grid) {\n                continue;\n            }\n            var toMerge = merging[m];\n            for (var i = 0; i < toMerge.length; i++) {\n                if (grids[toMerge[i].key]) {\n                    grid['sum']._add(toMerge[i].sum);\n                    grid['count'] += toMerge[i].count;\n                    grid['textSumProperty'] += toMerge[i].textSumProperty;\n                    grid['children'] = grid['children'].concat(toMerge[i].children);\n                    clusterMap[toMerge[i].key] = grid;\n                    delete grids[toMerge[i].key];\n                }\n            }\n            grid['center'] = grid['sum'].multi(1 / grid['count']);\n        }\n\n        return {\n            'clusters': grids,\n            'clusterMap': clusterMap\n        };\n    };\n\n    _class.prototype._distanceTo = function _distanceTo(c1, c2) {\n        var x = c1.x - c2.x,\n            y = c1.y - c2.y;\n        return Math.sqrt(x * x + y * y);\n    };\n\n    _class.prototype._stopAnim = function _stopAnim() {\n        if (this._player && this._player.playState !== 'finished') {\n            this._player.finish();\n        }\n    };\n\n    _class.prototype.onZoomStart = function onZoomStart(param) {\n        this._stopAnim();\n        _maptalks$renderer$Ve.prototype.onZoomStart.call(this, param);\n    };\n\n    _class.prototype.onZoomEnd = function onZoomEnd(param) {\n        if (this.layer.isEmpty() || !this.layer.isVisible()) {\n            _maptalks$renderer$Ve.prototype.onZoomEnd.apply(this, arguments);\n            return;\n        }\n        this._inout = param['from'] > param['to'] ? 'in' : 'out';\n        this._animated = true;\n        this._computeGrid();\n        _maptalks$renderer$Ve.prototype.onZoomEnd.apply(this, arguments);\n    };\n\n    _class.prototype._clearDataCache = function _clearDataCache() {\n        this._stopAnim();\n        delete this._markerExtent;\n        delete this._markerPoints;\n        delete this._clusterCache;\n        delete this._zoomInClusters;\n    };\n\n    return _class;\n}(renderer.VectorLayerCanvasRenderer));\n\nexport { ClusterLayer };\n\ntypeof console !== 'undefined' && console.log('maptalks.markercluster v0.8.2, requires maptalks@>=0.26.3.');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/maptalks.markercluster/dist/maptalks.markercluster.es.js\n// module id = null\n// module chunks = ","/*!\n * maptalks.heatmap v0.5.4\n * LICENSE : MIT\n * (c) 2016-2017 maptalks.org\n */\n/*!\n * requires maptalks@^0.25.0 \n */\nimport { Coordinate, Extent, Layer, Point, Util, renderer } from 'maptalks';\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar simpleheat_1 = createCommonjsModule(function (module) {\n    'use strict';\n\n    module.exports = simpleheat;\n\n    function simpleheat(canvas) {\n        if (!(this instanceof simpleheat)) return new simpleheat(canvas);\n\n        this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;\n\n        this._ctx = canvas.getContext('2d');\n        this._width = canvas.width;\n        this._height = canvas.height;\n\n        this._max = 1;\n        this._data = [];\n    }\n\n    simpleheat.prototype = {\n\n        defaultRadius: 25,\n\n        defaultGradient: {\n            0.4: 'blue',\n            0.6: 'cyan',\n            0.7: 'lime',\n            0.8: 'yellow',\n            1.0: 'red'\n        },\n\n        data: function data(_data) {\n            this._data = _data;\n            return this;\n        },\n\n        max: function max(_max) {\n            this._max = _max;\n            return this;\n        },\n\n        add: function add(point) {\n            this._data.push(point);\n            return this;\n        },\n\n        clear: function clear() {\n            this._data = [];\n            return this;\n        },\n\n        radius: function radius(r, blur) {\n            blur = blur === undefined ? 15 : blur;\n\n            // create a grayscale blurred circle image that we'll use for drawing points\n            var circle = this._circle = this._createCanvas(),\n                ctx = circle.getContext('2d'),\n                r2 = this._r = r + blur;\n\n            circle.width = circle.height = r2 * 2;\n\n            ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;\n            ctx.shadowBlur = blur;\n            ctx.shadowColor = 'black';\n\n            ctx.beginPath();\n            ctx.arc(-r2, -r2, r, 0, Math.PI * 2, true);\n            ctx.closePath();\n            ctx.fill();\n\n            return this;\n        },\n\n        resize: function resize() {\n            this._width = this._canvas.width;\n            this._height = this._canvas.height;\n        },\n\n        gradient: function gradient(grad) {\n            // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one\n            var canvas = this._createCanvas(),\n                ctx = canvas.getContext('2d'),\n                gradient = ctx.createLinearGradient(0, 0, 0, 256);\n\n            canvas.width = 1;\n            canvas.height = 256;\n\n            for (var i in grad) {\n                gradient.addColorStop(+i, grad[i]);\n            }\n\n            ctx.fillStyle = gradient;\n            ctx.fillRect(0, 0, 1, 256);\n\n            this._grad = ctx.getImageData(0, 0, 1, 256).data;\n\n            return this;\n        },\n\n        draw: function draw(minOpacity) {\n            if (!this._circle) this.radius(this.defaultRadius);\n            if (!this._grad) this.gradient(this.defaultGradient);\n\n            var ctx = this._ctx;\n\n            ctx.clearRect(0, 0, this._width, this._height);\n\n            // draw a grayscale heatmap by putting a blurred circle at each data point\n            for (var i = 0, len = this._data.length, p; i < len; i++) {\n                p = this._data[i];\n                ctx.globalAlpha = Math.max(p[2] / this._max, minOpacity === undefined ? 0.05 : minOpacity);\n                ctx.drawImage(this._circle, p[0] - this._r, p[1] - this._r);\n            }\n\n            // colorize the heatmap, using opacity value of each pixel to get the right color from our gradient\n            var colored = ctx.getImageData(0, 0, this._width, this._height);\n            this._colorize(colored.data, this._grad);\n            ctx.putImageData(colored, 0, 0);\n\n            return this;\n        },\n\n        _colorize: function _colorize(pixels, gradient) {\n            for (var i = 0, len = pixels.length, j; i < len; i += 4) {\n                j = pixels[i + 3] * 4; // get gradient color from opacity value\n\n                if (j) {\n                    pixels[i] = gradient[j];\n                    pixels[i + 1] = gradient[j + 1];\n                    pixels[i + 2] = gradient[j + 2];\n                }\n            }\n        },\n\n        _createCanvas: function _createCanvas() {\n            if (typeof document !== 'undefined') {\n                return document.createElement('canvas');\n            } else {\n                // create a new canvas instance in node.js\n                // the canvas class needs to have a default constructor without any parameter\n                return new this._canvas.constructor();\n            }\n        }\n    };\n});\n\nfunction _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }\n\nvar options = {\n    'max': 1,\n    'gradient': {\n        0.4: 'blue',\n        0.6: 'cyan',\n        0.7: 'lime',\n        0.8: 'yellow',\n        1.0: 'red'\n    },\n    'radius': 25,\n    'blur': 15,\n    'minOpacity': 0.05\n};\n\nvar HeatLayer = function (_maptalks$Layer) {\n    _inherits(HeatLayer, _maptalks$Layer);\n\n    function HeatLayer(id, heats, options) {\n        _classCallCheck(this, HeatLayer);\n\n        if (!Array.isArray(heats)) {\n            options = heats;\n            heats = null;\n        }\n\n        var _this = _possibleConstructorReturn(this, _maptalks$Layer.call(this, id, options));\n\n        _this._heats = heats || [];\n        return _this;\n    }\n\n    HeatLayer.prototype.getData = function getData() {\n        return this._heats;\n    };\n\n    HeatLayer.prototype.setData = function setData(heats) {\n        this._heats = heats || [];\n        return this.redraw();\n    };\n\n    HeatLayer.prototype.addPoint = function addPoint(heat) {\n        if (!heat) {\n            return this;\n        }\n        if (heat[0] && Array.isArray(heat[0])) {\n            Util.pushIn(this._heats, heat);\n        } else {\n            this._heats.push(heat);\n        }\n        return this.redraw();\n    };\n\n    HeatLayer.prototype.onConfig = function onConfig(conf) {\n        for (var p in conf) {\n            if (options[p]) {\n                return this.redraw();\n            }\n        }\n        return this;\n    };\n\n    HeatLayer.prototype.redraw = function redraw() {\n        var renderer$$1 = this._getRenderer();\n        if (renderer$$1) {\n            renderer$$1.clearHeatCache();\n            renderer$$1.setToRedraw();\n        }\n        return this;\n    };\n\n    HeatLayer.prototype.isEmpty = function isEmpty() {\n        if (!this._heats.length) {\n            return true;\n        }\n        return false;\n    };\n\n    HeatLayer.prototype.clear = function clear() {\n        this._heats = [];\n        this.redraw();\n        this.fire('clear');\n        return this;\n    };\n\n    /**\r\n     * Export the HeatLayer's JSON.\r\n     * @return {Object} layer's JSON\r\n     */\n\n\n    HeatLayer.prototype.toJSON = function toJSON(options) {\n        if (!options) {\n            options = {};\n        }\n        var json = {\n            'type': this.getJSONType(),\n            'id': this.getId(),\n            'options': this.config()\n        };\n        var data = this.getData();\n        if (options['clipExtent']) {\n            var clipExtent = new Extent(options['clipExtent']);\n            var r = this._getHeatRadius();\n            if (r) {\n                clipExtent = clipExtent._expand(r);\n            }\n            var clipped = [];\n            for (var i = 0, len = data.length; i < len; i++) {\n                if (clipExtent.contains(new Coordinate(data[i][0], data[i][1]))) {\n                    clipped.push(data[i]);\n                }\n            }\n            json['data'] = clipped;\n        } else {\n            json['data'] = data;\n        }\n\n        return json;\n    };\n\n    /**\r\n     * Reproduce a HeatLayer from layer's JSON.\r\n     * @param  {Object} json - layer's JSON\r\n     * @return {maptalks.HeatLayer}\r\n     * @static\r\n     * @private\r\n     * @function\r\n     */\n\n\n    HeatLayer.fromJSON = function fromJSON(json) {\n        if (!json || json['type'] !== 'HeatLayer') {\n            return null;\n        }\n        return new HeatLayer(json['id'], json['data'], json['options']);\n    };\n\n    HeatLayer.prototype._getHeatRadius = function _getHeatRadius() {\n        if (!this._getRenderer()) {\n            return null;\n        }\n        return this._getRenderer()._heatRadius;\n    };\n\n    return HeatLayer;\n}(Layer);\n\nHeatLayer.mergeOptions(options);\n\nHeatLayer.registerJSONType('HeatLayer');\n\nHeatLayer.registerRenderer('canvas', function (_maptalks$renderer$Ca) {\n    _inherits(_class, _maptalks$renderer$Ca);\n\n    function _class() {\n        _classCallCheck(this, _class);\n\n        return _possibleConstructorReturn(this, _maptalks$renderer$Ca.apply(this, arguments));\n    }\n\n    _class.prototype.draw = function draw() {\n        var map = this.getMap(),\n            layer = this.layer,\n            extent = map.getContainerExtent();\n        var maskExtent = this.prepareCanvas(),\n            displayExtent = extent;\n        if (maskExtent) {\n            maskExtent = maskExtent.convertTo(function (c) {\n                return map._pointToContainerPoint(c);\n            });\n            //out of layer mask\n            if (!maskExtent.intersects(extent)) {\n                this.completeRender();\n                return;\n            }\n            displayExtent = extent.intersection(maskExtent);\n        }\n\n        if (!this._heater) {\n            this._heater = simpleheat_1(this.canvas);\n        }\n        this._heater.radius(layer.options['radius'] || this._heater.defaultRadius, layer.options['blur']);\n        if (layer.options['gradient']) {\n            this._heater.gradient(layer.options['gradient']);\n        }\n        this._heater.max(layer.options['max']);\n        //a cache of heat points' viewpoints.\n        if (!this._heatViews) {\n            this._heatViews = [];\n        }\n\n        var heats = layer.getData();\n        if (heats.length === 0) {\n            this.completeRender();\n            return;\n        }\n        var data = this._heatData(heats, displayExtent);\n        this._heater.data(data).draw(layer.options['minOpacity']);\n        this.completeRender();\n    };\n\n    _class.prototype.drawOnInteracting = function drawOnInteracting() {\n        this.draw();\n    };\n\n    _class.prototype._heatData = function _heatData(heats, displayExtent) {\n        var map = this.getMap(),\n            layer = this.layer;\n        var projection = map.getProjection();\n        var data = [],\n            r = this._heater._r,\n            max = layer.options['max'] === undefined ? 1 : layer.options['max'],\n            maxZoom = Util.isNil(layer.options['maxZoom']) ? map.getMaxZoom() : layer.options['maxZoom'],\n            v = 1 / Math.pow(2, Math.max(0, Math.min(maxZoom - map.getZoom(), 12))),\n            cellSize = r / 2,\n            grid = [],\n            panePos = map.offsetPlatform(),\n            offsetX = panePos.x % cellSize,\n            offsetY = panePos.y % cellSize;\n        var heat = void 0,\n            p = void 0,\n            alt = void 0,\n            cell = void 0,\n            x = void 0,\n            y = void 0,\n            k = void 0;\n        displayExtent = displayExtent.expand(r).convertTo(function (c) {\n            return new Point(map._containerPointToPrj(c));\n        });\n        this._heatRadius = r;\n        for (var i = 0, l = heats.length; i < l; i++) {\n            heat = heats[i];\n            if (!this._heatViews[i]) {\n                this._heatViews[i] = projection.project(new Coordinate(heat[0], heat[1]));\n            }\n            p = this._heatViews[i];\n            if (displayExtent.contains(p)) {\n                p = map._prjToContainerPoint(p);\n                x = Math.floor((p.x - offsetX) / cellSize) + 2;\n                y = Math.floor((p.y - offsetY) / cellSize) + 2;\n\n                alt = heat.alt !== undefined ? heat.alt : heat[2] !== undefined ? +heat[2] : 1;\n                k = alt * v;\n\n                grid[y] = grid[y] || [];\n                cell = grid[y][x];\n\n                if (!cell) {\n                    grid[y][x] = [p.x, p.y, k];\n                } else {\n                    cell[0] = (cell[0] * cell[2] + p.x * k) / (cell[2] + k); // x\n                    cell[1] = (cell[1] * cell[2] + p.y * k) / (cell[2] + k); // y\n                    cell[2] += k; // cumulated intensity value\n                }\n            }\n        }\n        for (var _i = 0, _l = grid.length; _i < _l; _i++) {\n            if (grid[_i]) {\n                for (var j = 0, ll = grid[_i].length; j < ll; j++) {\n                    cell = grid[_i][j];\n                    if (cell) {\n                        data.push([Math.round(cell[0]), Math.round(cell[1]), Math.min(cell[2], max)]);\n                    }\n                }\n            }\n        }\n        return data;\n    };\n\n    _class.prototype.onZoomEnd = function onZoomEnd() {\n        delete this._heatViews;\n        _maptalks$renderer$Ca.prototype.onZoomEnd.apply(this, arguments);\n    };\n\n    _class.prototype.onResize = function onResize() {\n        if (this.canvas) {\n            this._heater._width = this.canvas.width;\n            this._heater._height = this.canvas.height;\n        }\n        _maptalks$renderer$Ca.prototype.onResize.apply(this, arguments);\n    };\n\n    _class.prototype.onRemove = function onRemove() {\n        this.clearHeatCache();\n        delete this._heater;\n    };\n\n    _class.prototype.clearHeatCache = function clearHeatCache() {\n        delete this._heatViews;\n    };\n\n    return _class;\n}(renderer.CanvasRenderer));\n\nexport { HeatLayer };\n\ntypeof console !== 'undefined' && console.log('maptalks.heatmap v0.5.4, requires maptalks@^0.25.0.');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/maptalks.heatmap/dist/maptalks.heatmap.es.js\n// module id = null\n// module chunks = ","<template>\n  <div>\n    <div id=\"map\" class=\"container\"></div>\n    <button @click=\"updateLayer(1)\">添加点</button>\n    <button @click=\"updateLayer(2)\">聚类</button>\n    <button @click=\"updateLayer(3)\">热力图层</button>\n    <button @click=\"clearlayer()\">清除</button>\n    <button @click=\"distance()\">测距</button>\n    <button @click=\"area()\">测面</button>\n  </div>\n</template>\n\n<script>\nimport * as maptalks from \"maptalks\";\nimport * as turf from \"turf\";\nimport { ClusterLayer } from \"maptalks.markercluster\";\nimport { HeatLayer } from \"maptalks.heatmap\";\nexport default {\n  data() {\n    return {\n      name: \"map\",\n      map: null,\n      markerVectorLayer: null, //点图层\n      clusterLayer: null, //聚类图层\n      heatLayer: null, //热力图层\n      distanceTool: null, //测量距离\n      areaTool: null, //测量面积\n      addressPoints: [\n        //点数据\n        [-37.6433062833, 175.2721598, \"3\"],\n        [-37.8129763667, 175.2714296333, \"10\"],\n        [-37.71369515, 175.2414571167, \"11\"],\n        [-37.81322845, 175.2815556, \"12\"],\n        [-37.8137875333, 175.2712745333, \"13\"],\n        [-37.8433246833, 175.57138025, \"14\"],\n        [-37.8140672667, 175.2712932667, \"15\"],\n        [-37.8131234, 175.2811189833, \"16\"],\n        [-37.7507629167, 175.2502213833, \"34\"],\n        [-37.7305923333, 175.2499560667, \"35\"],\n        [-37.5508608333, 175.3500617167, \"36\"],\n        [-37.6506927833, 175.2898010667, \"37\"],\n        [-37.7509818, 175.2499128333, \"38\"]\n      ]\n    };\n  },\n  methods: {\n    initMap: function() {\n      this.map = new maptalks.Map(\"map\", {\n        center: [175, -37.898568],\n        zoom: 8,\n        baseLayer: new maptalks.TileLayer(\"base\", {\n          urlTemplate: \"http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",\n          subdomains: [\"a\", \"b\", \"c\"],\n          attribution:\n            '&copy; <a href=\"http://www.osm.org\" target=\"_blank\">OpenStreetMap</a> contributors'\n        })\n      });\n    },\n    updateLayer: function(type) {\n      var that = this;\n      this.removeAllLayer();\n      switch (type) {\n        case 1:\n          that.addMarker();\n          break;\n        case 2:\n          that.addclusterLayer();\n          break;\n        case 3:\n          that.addHeatLayer();\n      }\n    },\n    removeAllLayer() {\n      var that = this;\n      if (that.clusterLayer != null) {\n        that.map.removeLayer(that.clusterLayer);\n        //that.clusterLayer = null;\n      }\n      if (that.markerVectorLayer != null) {\n        that.map.removeLayer(that.markerVectorLayer);\n        that.markerVectorLayer = null;\n      }\n      if (that.heatLayer != null) {\n        that.map.removeLayer(that.heatLayer);\n        that.heatLayer = null;\n      }\n      if (that.distanceTool != null) {\n        that.distanceTool.clear(); //清除线\n      }\n    },\n    addMarker: function() {\n      if (this.markerVectorLayer == null) {\n        this.markerVectorLayer = new maptalks.VectorLayer(\"makerVector\");\n        this.markerVectorLayer.addTo(this.map);\n      }\n      var point = new maptalks.Marker([175, -37.898568], {\n        visible: true,\n        editable: true,\n        cursor: \"pointer\",\n        shadowBlur: 0,\n        shadowColor: \"black\",\n        draggable: false,\n        dragShadow: false, // display a shadow during dragging\n        drawOnAxis: null // force dragging stick on a axis, can be: x, y\n      });\n      this.markerVectorLayer.addGeometry(point);\n    },\n    addclusterLayer: function() {\n      var vm = this;\n      var clustervectorLayer = new maptalks.VectorLayer(\"vc\").addTo(vm.map);\n\n      var markers = [];\n      for (var i = 0; i < this.addressPoints.length; i++) {\n        var a = this.addressPoints[i];\n        var _marker = new maptalks.Marker([a[1], a[0]]);\n        var options = {\n          title: \"信息框\",\n          content: a[2]\n        };\n        _marker.attributes = \"ooouang\";\n        var infoWindow = new maptalks.ui.InfoWindow(options);\n        //var _infoWin = infoWindow.addTo(_marker);\n        // _marker.on(\"click\", function(e) {\n        //   !_infoWin.isVisible()\n        //     ? _infoWin.show(e.target.getCenter())\n        //     : _infoWin.hide();\n        // });\n        markers.push(_marker);\n      }\n      if (this.clusterLayer == null) {\n        this.clusterLayer = new ClusterLayer(\"cluster\", markers, {\n          noClusterWithOneMarker: false,\n          maxClusterZoom: 18,\n          //\"count\" is an internal variable: marker count in the cluster.\n          symbol: {\n            markerType: \"ellipse\",\n            markerFill: {\n              property: \"count\",\n              type: \"interval\",\n              stops: [\n                [0, \"rgb(135, 196, 240)\"],\n                [9, \"#1bbc9b\"],\n                [99, \"#f54e24\"]\n              ]\n            },\n            markerFillOpacity: 0.7,\n            markerLineOpacity: 1,\n            markerLineWidth: 3,\n            markerLineColor: \"#fff\",\n            markerWidth: {\n              property: \"count\",\n              type: \"interval\",\n              stops: [[0, 40], [9, 60], [99, 80]]\n            },\n            markerHeight: {\n              property: \"count\",\n              type: \"interval\",\n              stops: [[0, 40], [9, 60], [99, 80]]\n            }\n          },\n          drawClusterText: true,\n          geometryEvents: true,\n          single: true\n        });\n      }\n      this.map.addLayer(this.clusterLayer);\n      vm.map.on(\"zoomend\", function() {\n        clustervectorLayer.clear();\n      });\n      vm.map.on(\"click\", function(e) {\n        clustervectorLayer.clear();\n        var result = vm.clusterLayer.identify(e.coordinate);\n        //console.log(result);\n        var features = [];\n        //没点击到聚类图标和判断小于三个点的情况\n        if (result.children != undefined && result.children.length > 2) {\n          result.children.forEach(element => {\n            var coord = element.getCoordinates();\n            if (result.children.length < 20) {\n              //createline(e.coordinate, coord);\n            }\n            // console.log(coord);\n            features.push({\n              type: \"Feature\",\n              properties: {},\n              geometry: {\n                type: \"Point\",\n                coordinates: [coord.x, coord.y]\n              }\n            });\n          });\n          var points = { type: \"FeatureCollection\", features: features };\n          //点集合转面\n          var hull = turf.convex(points);\n          console.log(hull);\n          var convex = new maptalks.Polygon(hull.geometry.coordinates, {\n            symbol: {\n              polygonFill: \"#f984e1\",\n              polygonOpacity: 0.6,\n              lineColor: \"#11ffbc\"\n            }\n          }).addTo(clustervectorLayer);\n        }\n      });\n    },\n    addHeatLayer: function() {\n      var vm = this;\n      var data = this.addressPoints.map(function(p) {\n        return [p[1], p[0]];\n      });\n      if (vm.heatLayer == null) {\n        vm.heatLayer = new HeatLayer(\"heat\", data, {\n          forceRenderOnRotating: true,\n          forceRenderOnMoving: true,\n          minOpacity: 0.5,\n          radius: 20, //数字半径\n          blur: 15, //模糊半径\n          gradient: { 0.4: \"blue\", 0.65: \"lime\", 1: \"red\" }\n        });\n        vm.map.addLayer(vm.heatLayer);\n      }\n    },\n    clearlayer: function() {\n      this.removeAllLayer();\n    },\n    distance: function() {\n      this.distanceTool = new maptalks.DistanceTool({\n        symbol: {\n          lineColor: \"#34495e\",\n          lineWidth: 2\n        },\n        vertexSymbol: {\n          markerType: \"ellipse\",\n          markerFill: \"#1bbc9b\",\n          markerLineColor: \"#000\",\n          markerLineWidth: 3,\n          markerWidth: 10,\n          markerHeight: 10\n        },\n\n        labelOptions: {\n          textSymbol: {\n            textFaceName: \"monospace\",\n            textFill: \"#fff\",\n            textLineSpacing: 1,\n            textHorizontalAlignment: \"right\",\n            textDx: 15,\n            markerLineColor: \"#b4b3b3\",\n            markerFill: \"#000\"\n          },\n          boxStyle: {\n            padding: [6, 2],\n            symbol: {\n              markerType: \"square\",\n              markerFill: \"#000\",\n              markerFillOpacity: 0.9,\n              markerLineColor: \"#b4b3b3\"\n            }\n          }\n        },\n        clearButtonSymbol: [\n          {\n            markerType: \"square\",\n            markerFill: \"#000\",\n            markerLineColor: \"#b4b3b3\",\n            markerLineWidth: 2,\n            markerWidth: 15,\n            markerHeight: 15,\n            markerDx: 20\n          },\n          {\n            markerType: \"x\",\n            markerWidth: 10,\n            markerHeight: 10,\n            markerLineColor: \"#fff\",\n            markerDx: 20\n          }\n        ],\n        language: \"zh-CN\"\n      }).addTo(this.map);\n      //this.distanceTool.disable();\n    },\n    area: function() {\n      this.areaTool = new maptalks.AreaTool({\n        symbol: {\n          lineColor: \"#1bbc9b\",\n          lineWidth: 2,\n          polygonFill: \"#fff\",\n          polygonOpacity: 0.3\n        },\n        vertexSymbol: {\n          markerType: \"ellipse\",\n          markerFill: \"#34495e\",\n          markerLineColor: \"#1bbc9b\",\n          markerLineWidth: 3,\n          markerWidth: 10,\n          markerHeight: 10\n        },\n        labelOptions: {\n          textSymbol: {\n            textFaceName: \"monospace\",\n            textFill: \"#fff\",\n            textLineSpacing: 1,\n            textHorizontalAlignment: \"right\",\n            textDx: 15\n          },\n          boxStyle: {\n            padding: [6, 2],\n            symbol: {\n              markerType: \"square\",\n              markerFill: \"#000\",\n              markerFillOpacity: 0.9,\n              markerLineColor: \"#b4b3b3\"\n            }\n          }\n        },\n        clearButtonSymbol: [\n          {\n            markerType: \"square\",\n            markerFill: \"#000\",\n            markerLineColor: \"#b4b3b3\",\n            markerLineWidth: 2,\n            markerWidth: 15,\n            markerHeight: 15,\n            markerDx: 22\n          },\n          {\n            markerType: \"x\",\n            markerWidth: 10,\n            markerHeight: 10,\n            markerLineColor: \"#fff\",\n            markerDx: 22\n          }\n        ],\n        language: \"zh-CN\"\n      }).addTo(this.map);\n    }\n  },\n  mounted() {\n    this.initMap();\n  }\n};\n</script>\n\n<style>\n.container {\n  height: 80vh;\n  width: 100%;\n  border: 1px solid;\n}\n</style>\n\n\n// WEBPACK FOOTER //\n// src/views/map/maptalks/map.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:\"container\",attrs:{\"id\":\"map\"}}),_vm._v(\" \"),_c('button',{on:{\"click\":function($event){_vm.updateLayer(1)}}},[_vm._v(\"添加点\")]),_vm._v(\" \"),_c('button',{on:{\"click\":function($event){_vm.updateLayer(2)}}},[_vm._v(\"聚类\")]),_vm._v(\" \"),_c('button',{on:{\"click\":function($event){_vm.updateLayer(3)}}},[_vm._v(\"热力图层\")]),_vm._v(\" \"),_c('button',{on:{\"click\":function($event){_vm.clearlayer()}}},[_vm._v(\"清除\")]),_vm._v(\" \"),_c('button',{on:{\"click\":function($event){_vm.distance()}}},[_vm._v(\"测距\")]),_vm._v(\" \"),_c('button',{on:{\"click\":function($event){_vm.area()}}},[_vm._v(\"测面\")])])}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-9e757ffe\",\"hasScoped\":false,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/views/map/maptalks/map.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-9e757ffe\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./map.vue\")\n}\nvar normalizeComponent = require(\"!../../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./map.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./map.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-9e757ffe\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../../node_modules/vue-loader/lib/selector?type=template&index=0!./map.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/map/maptalks/map.vue\n// module id = null\n// module chunks = "],"sourceRoot":""}